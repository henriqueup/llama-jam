# Migration Plan: Lemonfy to Llama Jam

This document outlines the plan for migrating the [Lemonfy](https://github.com/henriqueup/lemonfy) application (built with Next.js/T3 Stack) to Llama Jam (using React Router).
It was generated by Augment Agent under the following prompts:
```
-- Promt 1
Hey Augment! The current workspace is divided into 2 root forlders, @lemonfy/ and @llama-jam/. The former is the original implementation of my Songsterr inspired website. It is built using the T3 stack, leveraging mainly nextjs. The latter is supposed to be (eventually and with your help) a new version of the same system, but using a simpler stack based on React Router.

First of all, can you provide a documentation on how @lemonfy/ is built? I'd like you to create sections for the following:
- Architecture
- Libraries and packages used
- Features and functionalities

-- Promt 2
I think you did a pretty good job with a high level documentation, thanks! Now with the described system in mind, I'd like to create a new implementation under @llama-jam/, based on React Router instead of Next.js. You can also think of this as a migration of the existing system into new technologies.

Can you help me by generating a plan for such a migration? Please include detailed steps and highlight the challenges that might stand out.
```

## Overview

The migration involves transitioning from a Next.js-based application to a React Router-based application while maintaining the core functionality and features. This is not just a simple port but a strategic reimplementation that leverages the strengths of React Router while preserving the business logic and user experience of the original application.

## Current Architecture (Lemonfy)

- **Frontend Framework**: Next.js
- **API Layer**: tRPC
- **Database ORM**: Prisma
- **State Management**: Zustand
- **Styling**: Tailwind CSS
- **Form Handling**: React Hook Form + Zod
- **Routing**: Next.js Pages Router

## Target Architecture (Llama Jam)

- **Frontend Framework**: React + React Router
- **API Layer**: Custom fetch-based API client
- **Database**: SQLite with better-sqlite3
- **State Management**: Zustand (maintained)
- **Styling**: Tailwind CSS (maintained)
- **Form Handling**: React Hook Form + Zod (maintained)
- **Routing**: React Router

## Migration Strategy

The migration will follow a phased approach:

1. **Setup & Infrastructure**
2. **Core Components & Utilities**
3. **State Management**
4. **Routing & Navigation**
5. **API Integration**
6. **Feature Implementation**
7. **Testing & Refinement**

## Detailed Migration Steps

### Phase 1: Setup & Infrastructure

1. **Update Dependencies**
   - Add missing dependencies to package.json:
   ```json
   {
     "dependencies": {
       "zustand": "^4.4.1",
       "immer": "^10.0.2",
       "zod": "^3.22.2",
       "react-hook-form": "^7.46.1",
       "@hookform/resolvers": "^3.3.1",
       "@tanstack/react-query": "^4.35.3",
       "clsx": "^1.2.1",
       "tailwind-merge": "^1.14.0",
       "class-variance-authority": "^0.6.1",
       "better-sqlite3": "^9.0.0"
     },
     "devDependencies": {
       // existing dev dependencies...
     }
   }
   ```

2. **Setup Project Structure**
   - Create the following directory structure:
   ```
   llama-jam/web-app/
   ├── app/
   │   ├── components/       # Reusable UI components
   │   ├── db/               # Database related code
   │   │   ├── sql/          # SQL scripts for schema and migrations
   │   │   ├── migrations/   # Migration runner and version tracking
   │   │   └── repositories/ # Data access repositories with raw SQL
   │   ├── hooks/            # Custom React hooks
   │   ├── icons/            # SVG icons
   │   ├── lib/              # Utility functions
   │   │   ├── models/       # Entity models and validation
   │   │   └── db.ts         # Database connection utilities
   │   ├── routes/           # React Router routes
   │   │   ├── _layout.tsx   # Root layout
   │   │   ├── index.tsx     # Home page
   │   │   ├── songs/        # Song list
   │   │   ├── editor/       # Song editor
   │   │   ├── player/       # Song player
   │   │   └── api/          # API resource routes
   │   ├── store/            # State management
   │   │   ├── editor/       # Editor state
   │   │   ├── player/       # Player state
   │   │   └── global/       # Global state
   │   ├── styles/           # Global styles
   │   └── types/            # TypeScript types
   ├── public/               # Static assets
   └── data/                 # SQLite database files
   ```

3. **Configure Tailwind CSS**
   - Update tailwind.config.js to match the original configuration
   - Copy over custom theme settings

### Phase 2: Core Components & Utilities

1. **Port Utility Functions**
   - Copy and adapt utility functions from `src/utils/` to `app/lib/`
   - Implement the `cn` utility for class name merging

2. **Port UI Components**
   - Migrate base components from `src/components/` to `app/components/`
   - Adapt components to work with React Router instead of Next.js
   - Implement UI components in this order:
     - Basic UI components (Button, TextField, etc.)
     - Layout components (TopbarMenu, ErrorBoundary, etc.)
     - Complex components (Sheet, Bar, Note, etc.)

3. **Port Icons**
   - Copy SVG icons from `src/icons/` to `app/icons/`

### Phase 3: State Management

1. **Port Global Store**
   - Copy the global store from `src/store/global/` to `app/store/global/`
   - Adapt as needed for React Router

2. **Port Editor Store**
   - Copy the editor store from `src/store/editor/` to `app/store/editor/`
   - Adapt actions and selectors

3. **Port Player Store**
   - Copy the player store from `src/store/player/` to `app/store/player/`
   - Adapt audio playback functionality

4. **Implement Entity Models**
   - Copy entity models from `src/server/entities/` to `app/lib/models/`
   - Adapt validation schemas

### Phase 4: Routing & Navigation

1. **Define Routes**
   - Update `app/routes.ts` to define all necessary routes:
   ```typescript
   import { type RouteConfig, index, route } from "@react-router/dev/routes";

   export default [
     index("routes/home.tsx"),
     route("routes/songs/index.tsx", {
       path: "/songs",
     }),
     route("routes/editor/index.tsx", {
       path: "/editor",
     }),
     route("routes/editor/$songId.tsx", {
       path: "/editor/:songId",
     }),
     route("routes/player/$songId.tsx", {
       path: "/player/:songId",
     }),
   ] satisfies RouteConfig;
   ```

2. **Implement Layout Component**
   - Create a root layout in `app/root.tsx` that includes:
     - TopbarMenu
     - ErrorBoundary
     - Loading indicator
     - Toaster

3. **Implement Navigation**
   - Replace Next.js `useRouter` with React Router's `useNavigate` and `useParams`
   - Update all navigation links and buttons

4. **Handle Route Transitions**
   - Implement unsaved changes detection and confirmation dialogs
   - Handle loading states during navigation

### Phase 5: Database and API Integration

1. **Setup SQLite Database**
   - Add better-sqlite3 dependency
   - Create SQL scripts for table creation based on the existing Prisma schema
   - Implement database initialization script
   - Create a simple migration system using SQL scripts

2. **Create Data Access Layer**
   - Implement a database connection manager
   - Create repository classes with raw SQL queries
   - Implement prepared statements for performance and security
   - Create utility functions for common SQL operations
   - Implement transaction support with explicit begin/commit/rollback

3. **Create API Client**
   - Implement server-side API handlers using React Router's resource routes
   - Use React Query for data fetching and caching on the client side
   - Create type-safe interfaces for API requests and responses

4. **Implement Data Loaders**
   - Use React Router's data loading capabilities for route data
   - Implement loaders for song list, song details, etc.
   - Connect loaders to the SQLite repositories
   - Handle database errors and provide meaningful error messages

5. **Implement Form Actions**
   - Use React Router's form actions for mutations
   - Implement actions for creating/updating songs, etc.
   - Add comprehensive validation before database operations
   - Implement proper error handling and user feedback

### Phase 6: Feature Implementation

1. **Implement Home Page**
   - Port the home page from `src/pages/index.page.tsx`
   - Adapt to React Router

2. **Implement Song List**
   - Create a new song list page
   - Implement filtering and sorting

3. **Implement Song Editor**
   - Port the editor from `src/pages/editor/`
   - Implement sheet editing functionality
   - Implement bar and note management

4. **Implement Song Player**
   - Port the player functionality
   - Implement audio playback controls

5. **Implement Instrument Management**
   - Port instrument selection and configuration

### Phase 7: Testing & Refinement

1. **Manual Testing**
   - Test all features and functionality
   - Verify that the application works as expected

2. **Performance Optimization**
   - Identify and fix performance bottlenecks
   - Optimize rendering and data fetching

3. **Accessibility Improvements**
   - Ensure the application is accessible
   - Fix any accessibility issues

4. **Final Polishing**
   - Fix any remaining bugs
   - Improve user experience

## Key Challenges and Solutions

### 1. Routing Differences

**Challenge**: Next.js uses a file-based routing system, while React Router uses a configuration-based approach.

**Solution**:
- Map Next.js pages to React Router routes
- Use React Router's nested routes to replicate Next.js layout patterns
- Implement data loading with React Router's loaders instead of Next.js's getServerSideProps/getStaticProps

### 2. Database and API Layer Transition

**Challenge**: Moving from Prisma ORM and tRPC to direct SQL with better-sqlite3 and a custom API client.

**Solution**:
- Write raw SQL queries using better-sqlite3 for all database operations
- Create repository classes with prepared statements for security and performance
- Implement manual type checking and validation for database operations
- Use React Router's resource routes for API endpoints
- Use React Query for data fetching and caching
- Implement comprehensive error handling for SQL operations

### 3. Server-Side Rendering

**Challenge**: Maintaining SSR capabilities when moving from Next.js to React Router.

**Solution**:
- Use React Router's SSR capabilities
- Implement data loading with loaders
- Use React Router's deferred data loading for improved performance

### 4. Audio Playback

**Challenge**: Ensuring the Web Audio API integration works correctly in the new architecture.

**Solution**:
- Port the audio context hook and playback functionality
- Test thoroughly to ensure timing and playback are accurate
- Optimize for performance

### 5. State Management

**Challenge**: Ensuring Zustand stores work correctly with React Router.

**Solution**:
- Adapt store initialization and cleanup for React Router's lifecycle
- Use React Router's loaders to initialize stores with server data
- Implement proper cleanup on route changes

### 6. SQLite Database Management

**Challenge**: Managing SQLite database with raw SQL in a React Router application.

**Solution**:
- Implement a robust database connection management system
- Create SQL scripts for schema creation and migrations
- Write a simple script-based migration runner
- Develop comprehensive error handling for SQL operations
- Implement proper transaction management with explicit SQL commands
- Create utility functions for common SQL operations
- Ensure proper data validation before executing SQL commands

## Timeline Estimate

- **Phase 1**: 1-2 days
- **Phase 2**: 3-5 days
- **Phase 3**: 2-3 days
- **Phase 4**: 2-3 days
- **Phase 5**: 5-7 days (increased due to SQLite implementation)
- **Phase 6**: 5-7 days
- **Phase 7**: 3-5 days

**Total**: 21-32 days (depending on complexity and unforeseen challenges)

## Conclusion

This migration plan provides a structured approach to transitioning from the Next.js-based Lemonfy application to the React Router-based Llama Jam application. By following this plan, we can ensure a smooth migration while maintaining the core functionality and user experience of the original application.

The phased approach allows for incremental progress and testing, reducing the risk of major issues during the migration. The focus on maintaining the same state management, styling, and form handling libraries helps minimize the changes required and leverages existing knowledge and code.
